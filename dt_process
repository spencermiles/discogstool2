#!/usr/bin/env python3

import glob
import argparse
import client_interface
import re
import sys
import os
import time
import libtags
import tempfile
import shutil
import subprocess
import wavfile
import multiprocessing
from multiprocessing import Pool, TimeoutError

release_regex = re.compile(r"[[]r([0-9]+)[]][.][a-zA-Z]+$")
fregex = re.compile(r"([0-9]+)(([a-zA-Z)+[0-9]*)|[.]([a-zA-Z0-9. ]+))[.]([a-zA-Z]+)$")
pregex = re.compile(r"([a-zA-Z]+)([0-9]+)")

class ConversionException(Exception):
    pass

def debug(*strs):
    if not args.verbose:
        return
    print(multiprocessing.current_process().name, strs)

def file_extension(path):
    return "." + path.rsplit(".", 1)[1]

def new_tmp(ext):
    fo, tmppath = tempfile.mkstemp(suffix=ext, dir=tmpdir)
    os.close(fo)
    debug("New temp %s file: %s" % (ext, tmppath))
    return tmppath

def copy_to_tmp(path):
    ext = file_extension(path)
    tmpfil = new_tmp(ext)
    debug("Copying %s to temporary location %s..." % (path, tmpfil))
    shutil.copy(path, tmpfil)
    return tmpfil

# Moves file to new filename with metadata applied
def process_file(path, basedir, track):
    af = libtags.AudioFile(path, track)
    af.commit()
    dest = af.rename_file(basedir, args.verbose, False, True, False)
    debug("Renamed %s -> %s:" % (path, dest))

# if copy, don't do anything the modifies in place
# if not copy, delete path when we are done
def process_wav_file(path, basedir, track, copy):
    tmpaiff = new_tmp(".aiff")

    if copy:
        path = copy_to_tmp(path)

    debug("Normalizing...")
    retval = subprocess.call(["normalize-audio", "-q", "-T", "1.5", "--peak",
	    path])
    if retval:
        raise ConversionException("Normalization failed")

    debug("Converting to 44.1/16 AIFF...")
    retval = subprocess.call(["ffmpeg", "-hide_banner", "-loglevel", "panic",
            "-y",  "-i", path, "-sample_fmt", "s16", "-ar", "44100",
            tmpaiff])
    if retval:
        raise ConversionException("Encoding failed")
    process_file(tmpaiff, basedir, track)

def process_flac_file(path, basedir, track):
    tmpwav = new_tmp(".wav")
    debug("Converting to intermediate .wav...")
    retval = subprocess.call(["flac", "--silent", "-f", "-d", "-o", tmpwav, path])
    if retval:
        raise ConversionException("FLAC decoding failed")
    process_wav_file(tmpwav, basedir, track, False)

def process_mp3_file(path, basedir, track, copy):
    # Make a copy and process the copied file
    tmpfil = copy_to_tmp(path)
    process_file(tmpfil, basedir, track)

def get_wav_regions(markers, rate, min_len):
    regions = []
    for i in range(len(markers) - 1):
        start = markers[i]     # inclusive
        end = markers[i + 1]   # not inclusive
        duration = (end - start) / rate;
        if (duration < min_len):
            continue

        debug("Region (%d, %d), %d seconds" % (start, end, duration))
        regions.append((start, end))
    return regions

def split_wav_file(path, outdir, releaseid):
    rel = client_interface.DiscogsRelease(releaseid)
    print("split %s (%s)" % (path, rel))

    rate, rdata, bits, markers = wavfile.read(path, readmarkers=True)
    debug("%d samples" % len(rdata))
    markers.extend([0, len(rdata)])
    markers.sort()

    debug("Markers:", markers)
    regions = get_wav_regions(markers, rate, 30)

    if len(regions) != rel.getTotalTracks():
        # Try again with only 10 second gaps
        # Thanks, Giegling 20
        regions = get_wav_regions(markers, rate, 10)
        if len(regions) != rel.getTotalTracks():
            raise ConversionException("Unexpected region count %d" % len(regions))

    created = []
    for i in range(rel.getTotalTracks()):
        start, end = regions[i]
        tdata = rdata[start:end]
        track = rel.getTrack(i)
        pos = track["position"]

        filename = os.path.join(outdir, "%d.%s.wav" % (rel.getId(), pos))
        debug("Writing %s..." % filename)
        wavfile.write(filename, rate, tdata, bitrate=bits)
        created.append((track, filename, "wav", False))
    return created

def get_possible_positions(position):
    ret = [position]

    # A1 might just be A
    if position[-1] == "1":
        ret.append(position[:-1])
    elif not position[-1].isdigit():
        # ... or A might actually be A1
        ret.append(position + "1")

    ret2 = []
    for item in ret:
        ret2.append(item)
        if item[0] == "B":
            ret2.append("AA" + item[1:])
    ret = ret2

    ret2 = []
    # Some people do this, annoying
    for item in ret:
        ret2.append(item)
        ret2.append(item + ".")

        # 1B instead of B1, seen this at least once
        m = pregex.match(item)
        if m:
            l, n = m.groups()
            ret2.append("%s%s" % (n, l))

    ret = ret2

    return ret2

def get_release_and_track(releaseid, position):
    rel = client_interface.DiscogsRelease(releaseid)

    rdata = rel.data
    if not rdata:
        print(("Release %d not found" % releaseid))
        return None

    positions = get_possible_positions(position.upper())

    for i in range(len(rdata["tracklist"])):
        track = rdata["tracklist"][i]
        tp = track["position"].upper()
        for p in positions:
            if p == tp:
                return rel.getTrack(i)

    print("Couldn't find position %s in release %s" %
		    (position, rdata["title"]))
    return None

def process_track(trackinfo):
    track, path, extension, copy = trackinfo
    basedir = args.basedir

    print(path, "-->", track)
    try:
        if extension == "wav":
            process_wav_file(path, basedir, track, copy)
        elif extension == "flac":
            process_flac_file(path, basedir, track)
        elif extension == "mp3":
            process_mp3_file(path, basedir, track, copy)
        else:
            print("Don't know how to handle", path)
            return

    except ConversionException as ce:
        print(ce)

def poolsplit(item):
    path, tmpdir, releaseid = item

    return split_wav_file(path, tmpdir, releaseid)

parser = argparse.ArgumentParser(
        description="Convert WAV/FLAC files to AIFF and tag them")
parser.add_argument("files", metavar="FILE", type=str, nargs="+",
        help="Files to convert")
parser.add_argument("-b", "--basedir", required=True)
parser.add_argument("-v", "--verbose", action="store_true")
parser.add_argument("-j", "--jobs", default=multiprocessing.cpu_count())

args = parser.parse_args(sys.argv[1:])

tracks = []
files = args.files
solo_tracks = []
split_wavs = []

os.makedirs(args.basedir, exist_ok=True)
tmpdir = tempfile.mkdtemp(dir=args.basedir)

try:
    for path in files:
        filename = os.path.basename(path)
        m = release_regex.match(filename)
        if not m:
            continue
        releaseid = int(m.group(1))
        split_wavs.append((path, tmpdir, releaseid))

    if split_wavs:
        print("Split %d .wav files..." % len(split_wavs))
        pool = Pool(processes=args.jobs)
        result = pool.map(poolsplit, split_wavs)
        pool.close()
        pool.join()
        for res in result:
            tracks.extend(res)

    for path in files:
        filename = os.path.basename(path)
        m = fregex.match(filename)
        if not m:
            debug('Skipping', filename)
            continue
        releaseid = m.group(1)
        extension = m.group(5)
        position = m.group(3).upper() if m.group(3) else m.group(4)
        extension = extension.lower()
        releaseid = int(releaseid)

        track = get_release_and_track(releaseid, position)
        if not track:
            print("Couldn't look up", filename)
            sys.exit(1)
        tracks.append((track, path, extension, True))

    print("Tag/convert %d audio files..." % len(tracks))
    pool = Pool(processes=args.jobs)
    f = pool.map(process_track, tracks)
    pool.close()
    pool.join()

except:
    raise
finally:
    shutil.rmtree(tmpdir, ignore_errors=True)

