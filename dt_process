#!/usr/bin/env python3

import glob
import argparse
import client_interface
import re
import sys
import os
import time
import libtags
import tempfile
import shutil
import subprocess
import wavfile
import multiprocessing
from multiprocessing import Pool, TimeoutError

release_regex = re.compile(r"[[]r([0-9]+)[]][.][a-zA-Z]+$")
fregex = re.compile(r"([0-9]+)(([a-zA-Z)+[0-9]*)|[.]([a-zA-Z0-9. ]+))[.]([a-zA-Z]+)$")
pregex = re.compile(r"([a-zA-Z]+)([0-9]+)")

class ConversionException(Exception):
    pass

def debug(*strs):
    if not args.verbose:
        return
    print(multiprocessing.current_process(), strs)

def process_file(path, basedir, track):
    ext = "." + path.rsplit(".", 1)[1]
    fo, tmpfil = tempfile.mkstemp(suffix=ext)
    os.close(fo)
    shutil.copy(path, tmpfil)
    af = libtags.AudioFile(tmpfil, track)
    af.commit()
    dest = af.rename_file(basedir, args.verbose, False, False, False)
    debug("New file:", dest)
    os.remove(tmpfil)

def process_wav_file(path, basedir, track, copy):
    fo, tmpaiff = tempfile.mkstemp(suffix=".aiff")
    os.close(fo)

    if copy:
        fo, tmpwav = tempfile.mkstemp(suffix=".wav")
        os.close(fo)
        debug("Copying to temporary location...")
        shutil.copyfile(path, tmpwav)
    else:
        tmpwav = path

    debug("Normalizing...")
    retval = subprocess.call(["normalize-audio", "-q", "-T", "1.5", "--peak",
	    tmpwav])
    if retval:
        raise ConversionException("Normalization failed")

    debug("Converting to 44.1/16 AIFF...")
    retval = subprocess.call(["ffmpeg", "-hide_banner", "-loglevel", "panic",
            "-y",  "-i", tmpwav, "-sample_fmt", "s16", "-ar", "44100",
            tmpaiff])
    if retval:
        raise ConversionException("Encoding failed")
    process_file(tmpaiff, basedir, track)
    os.remove(tmpwav)
    os.remove(tmpaiff)

def process_flac_file(path, basedir, track):
    fo, tmpwav = tempfile.mkstemp(suffix=".wav")
    os.close(fo)
    debug("Converting to intermediate .wav...")
    retval = subprocess.call(["flac", "--silent", "-f", "-d", "-o", tmpwav, path])
    if retval:
        raise ConversionException("FLAC decoding failed")
    process_wav_file(tmpwav, basedir, track, False)
    os.remove(tmpwav)

def get_wav_regions(markers, rate, min_len):
    regions = []
    for i in range(len(markers) - 1):
        start = markers[i]     # inclusive
        end = markers[i + 1]   # not inclusive
        duration = (end - start) / rate;
        if (duration < min_len):
            continue

        debug("Region (%d, %d), %d seconds" % (start, end, duration))
        regions.append((start, end))
    return regions

def split_wav_file(path, outdir, releaseid):
    rel = client_interface.DiscogsRelease(releaseid)
    print("split %s (%s)" % (path, rel))

    rate, rdata, bits, markers = wavfile.read(path, readmarkers=True)
    debug("%d samples" % len(rdata))
    markers.extend([0, len(rdata)])
    markers.sort()

    debug("Markers:", markers)
    regions = get_wav_regions(markers, rate, 30)

    if len(regions) != rel.getTotalTracks():
        # Try again with only 10 second gaps
        # Thanks, Giegling 20
        regions = get_wav_regions(markers, rate, 10)
        if len(regions) != rel.getTotalTracks():
            raise ConversionException("Unexpected region count %d" % len(regions))

    created = []
    for i in range(rel.getTotalTracks()):
        start, end = regions[i]
        tdata = rdata[start:end]
        track = rel.getTrack(i)
        pos = track["position"]

        filename = os.path.join(outdir, "%d.%s.wav" % (rel.getId(), pos))
        debug("Writing %s..." % filename)
        wavfile.write(filename, rate, tdata, bitrate=bits)
        created.append((track, filename, "wav", False))
    return created

def get_possible_positions(position):
    ret = [position]

    # A1 might just be A
    if position[-1] == "1":
        ret.append(position[:-1])
    elif not position[-1].isdigit():
        # ... or A might actually be A1
        ret.append(position + "1")

    ret2 = []
    for item in ret:
        ret2.append(item)
        if item[0] == "B":
            ret2.append("AA" + item[1:])
    ret = ret2

    ret2 = []
    # Some people do this, annoying
    for item in ret:
        ret2.append(item)
        ret2.append(item + ".")

        # 1B instead of B1, seen this at least once
        m = pregex.match(item)
        if m:
            l, n = m.groups()
            ret2.append("%s%s" % (n, l))

    ret = ret2

    return ret2

def get_release_and_track(releaseid, position):
    rel = client_interface.DiscogsRelease(releaseid)

    rdata = rel.data
    if not rdata:
        print(("Release %d not found" % releaseid))
        return None

    positions = get_possible_positions(position.upper())

    for i in range(len(rdata["tracklist"])):
        track = rdata["tracklist"][i]
        tp = track["position"].upper()
        for p in positions:
            if p == tp:
                return rel.getTrack(i)

    print("Couldn't find position %s in release %s" %
		    (position, rdata["title"]))
    return None

def process_track(trackinfo):
    track, path, extension, copy = trackinfo
    basedir = args.basedir

    print(path, "-->", track)
    try:
        if extension == "wav":
            process_wav_file(path, basedir, track, copy)
        elif extension == "flac":
            process_flac_file(path, basedir, track)
        elif extension == "mp3":
            process_file(path, basedir, track)
        else:
            print("Don't know how to handle", path)
            return

        if args.delete and not copy:
            os.remove(path)
    except ConversionException as ce:
        print(ce)

def poolsplit(item):
    path, tmpdir, releaseid = item

    return split_wav_file(path, tmpdir, releaseid)

parser = argparse.ArgumentParser(
        description="Convert WAV/FLAC files to AIFF and tag them")
parser.add_argument("-d", "--delete", action="store_true",
        help="Delete original file when finished")
parser.add_argument("files", metavar="FILE", type=str, nargs="+",
        help="Files to convert")
parser.add_argument("-b", "--basedir", required=True)
parser.add_argument("-v", "--verbose", action="store_true")
parser.add_argument("-j", "--jobs", default=multiprocessing.cpu_count())

args = parser.parse_args(sys.argv[1:])


tracks = []
files = args.files
tmpdir = tempfile.mkdtemp()

solo_tracks = []
split_wavs = []

try:
    for path in files:
        filename = os.path.basename(path)
        m = release_regex.match(filename)
        if not m:
            continue
        releaseid = int(m.group(1))
        split_wavs.append((path, tmpdir, releaseid))

    if split_wavs:
        pool = Pool(processes=args.jobs)
        result = pool.map(poolsplit, split_wavs)
        pool.close()
        pool.join()
        for res in result:
            tracks.extend(res)

    for path in files:
        filename = os.path.basename(path)
        m = fregex.match(filename)
        if not m:
            debug('Skipping', filename)
            continue
        releaseid = m.group(1)
        extension = m.group(5)
        position = m.group(3).upper() if m.group(3) else m.group(4)
        extension = extension.lower()
        releaseid = int(releaseid)

        track = get_release_and_track(releaseid, position)
        if not track:
            print("Couldn't look up", filename)
            sys.exit(1)

        tracks.append((track, path, extension, True))

    pool = Pool(processes=args.jobs)
    f = pool.map(process_track, tracks)
    pool.close()
    pool.join()

except:
    raise
finally:
    shutil.rmtree(tmpdir)

